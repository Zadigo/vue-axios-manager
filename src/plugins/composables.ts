import { useDebounceFn, watchDebounced } from '@vueuse/core'
import { useCookies } from '@vueuse/integrations/useCookies.mjs'
import axios, { AxiosError } from 'axios'
import { computed, getCurrentInstance, inject, ref } from 'vue'
import { vueAxiosManager } from './base'

import type { AxiosResponse, InternalAxiosRequestConfig } from 'axios'
import type { Ref } from 'vue'
import type { AsyncComposableOptions, ComposableOptions, Credentials, ExtendedInternalAxiosRequestConfig, InternalEnpointOptions, LoginComposableOptions, Methods, PluginOptions, RefreshApiResponse, RequestStoreClass } from './types'

export type RequestStatus = 'idle' | 'pending' | 'success' | 'error'

/**
 * Adds an access token to the request on authentication
 * tokens obtained for authenticating the user
 * @param request The request configuration
 */
function requestInterceptor(options: PluginOptions | undefined, endpoint: InternalEnpointOptions | null | undefined) {
  return (request: InternalAxiosRequestConfig) => {
    const { get } = useCookies()

    const bearer = endpoint?.bearer || options?.bearer || 'Token'
    const access = get(endpoint?.accessKey || 'access')

    if (access) {
      request.headers.Authorization = `${bearer} ${access}`
    }

    return request
  }
}

/**
 * Interceptor used to reject a request error
 * @param error The error generated by the request
 */
function requestErrorInterceptor(error: unknown) {
  return Promise.reject(error)
}

/**
 * Interceptor used to modify the state of a response
 * @param response The response for the request
 */
async function responseInterceptor(response: AxiosResponse) {
  return response
}

/**
 * Creates an interceptor for automatically refreshing
 * access tokens created via authentication for users
 * @param domain The url domain for the request
 */
function responseErrorInterceptor(domain: string | undefined, endpoint: InternalEnpointOptions | null | undefined) {
  return async (error: unknown) => {
    if (error && error instanceof AxiosError) {
      if (error.response) {
        const originalRequest = error.config as ExtendedInternalAxiosRequestConfig

        if (error.response.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true

          try {
            const accessTokenKey = endpoint?.accessKey || 'access'
            const refreshTokenKey = endpoint?.refreshKey || 'refresh'

            const { get, set } = useCookies([accessTokenKey, refreshTokenKey])
            const refresh = get<string | undefined>(refreshTokenKey)

            console.log('responseErrorInterceptor: Refresh', refresh)

            const refreshClient = axios.create({ baseURL: domain })
            const refreshTokenEndpoint = endpoint?.refreshEnpoint || '/auth/v1/token/refresh/'
            const response = await refreshClient.post<RefreshApiResponse>(refreshTokenEndpoint, { refresh })

            set(accessTokenKey, response.data.access, { secure: true, sameSite: 'strict' })

            return refreshClient
          } catch (refreshError) {
            return Promise.reject(refreshError)
          }
        }
      }
    }
    return Promise.reject(error)
  }
}

/**
 * Compsable used to send a request
 * @param name The name of the client to use
 * @param path The path to get on the client's domain
 * @param params Additional options for the composable
 */
export function useRequest<T>(name: string, path: string, params?: ComposableOptions<T>) {
  const app = getCurrentInstance()
  const isAppContext = computed(() => app !== null)

  const endpoint = vueAxiosManager.provideAttr[name]

  if (!endpoint) {
    throw new Error(`Endpoint with with name ${name} does not exist`)
  }

  let client = endpoint.instance

  console.log('vueAxiosManager', vueAxiosManager)

  // baseUrl allows the user to override
  // the initial client entirely for this
  // request -; this creates a new client
  if (params?.baseUrl) {
    client = axios.create({
      baseURL: params.baseUrl, // We allow http or https protocoles here
      ...endpoint.axios
    })
  }

  try {
    client.interceptors.request.use(requestInterceptor(vueAxiosManager.pluginOptions, vueAxiosManager.provideAttr[name]), requestErrorInterceptor)
    client.interceptors.response.use(responseInterceptor, responseErrorInterceptor(client.defaults.baseURL, vueAxiosManager.provideAttr[name]))
  } catch (e) {
    // @ts-expect-error Error could be anything so skip
    throw new Error(e)
  }

  let store: RequestStoreClass | undefined

  if (isAppContext.value) {
    // If we are in the context of a component
    // try to get the store with inject for
    // internal debug tracking
    store = inject<RequestStoreClass>('requestStore')
  }

  console.log('useRequest: RequestStore', store)

  const responseData = ref<T>()
  const status = ref<RequestStatus>('idle')

  /**
   * Function used to send a request
   * @param method Method to use for the given request
   * @param data Post data to pass to the body of the request
   * @param options Options to send with the request
   */
  async function execute() {
    if (params?.beforeStart) {
      params.beforeStart()
    }

    try {
      const method: Methods = params?.method || 'get'
      let response: AxiosResponse<T>

      status.value = 'pending'

      if (method === 'get') {
        response = await client.get(path, { params: params?.query })
      } else {
        response = await client[method](path, params?.body)
      }

      status.value = 'success'

      if (params?.completed) {
        params.completed(response)
      }

      console.log('execute.response', response)
      console.log('execute.store', store)

      if (store) {
        try {
          store.registerRequest({
            name,
            method,
            statusText: response.statusText,
            data: response.data || {},
            headers: JSON.stringify(response.headers),
            path: response.config.url
          })
        } catch (e) {
          console.error(e)
        }
      }

      console.log('useRequest: status', status.value)
      console.log('useRequest: responseData.value', responseData.value)
      console.log('useRequest: response.data', response.data)

      responseData.value = response.data
    } catch (e) {
      if (e && e instanceof AxiosError) {
        console.log('useRequest: Bubbled up error', e)
        status.value = 'error'
      }
    }
  }

  // TODO: Infer type
  if (params?.watch) {
    console.log('useRequest: Watch', params.watch)
    watchDebounced(params.watch, async () => {
      await execute()
    }, {
      debounce: 300,
      onTrigger() {
        console.log('useRequest: Watch', 'Executed')
      }
    })
  }

  return {
    /**
     * The status of the request
     */
    status,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * Function to execute the request
     */
    execute
  }
}

/**
 * Async composable with the option of immediately sending the request
 * or delaying the request until a certain time
 * @param name The name of the client to use
 * @param path The path to get on the client's domain
 * @param params Additional options for the composable
 */
export async function useAsyncRequest<T>(name: string, path: string, params?: AsyncComposableOptions<T>) {
  // FIXME: When trying to send a request with use async in "immediate", the
  // app in useRequest is "undefined" ->
  // 1. This might be due to the fact of using a composable within a composable ??
  // 2. This might be due to the useDebounceFn
  const { execute, responseData, status } = useRequest(name, path, params)
  const debouncedExecute = useDebounceFn(execute, params?.debounce || 0)

  if (params?.immediate) {
    await debouncedExecute()
  }

  const completed = computed(() => status.value === 'success')

  return {
    /**
     * Wrapped execute function that can be debounced
     */
    debouncedExecute,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * The status of the request
     */
    status,
    /**
     * Whether the request was completed
     */
    completed
  }
}

/**
 * Composable to log a user into the application
 * @param credentials The crendentials with which to log the user in
 * @param clientName The client name to use
 * @param path The path to log the client in
 * @param params The parameters for the request
 */
export async function useAxiosLogin<T>(credentials: Credentials, clientName: string, path: string, params: LoginComposableOptions<T>): Promise<Ref<T | unknown>> {
  const { execute, responseData } = useRequest<T>(clientName, path, { method: 'post', body: credentials, ...params })
  await execute()
  return responseData
}
