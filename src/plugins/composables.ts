import { useDebounceFn, watchDebounced } from '@vueuse/core'
import { useCookies } from '@vueuse/integrations/useCookies.mjs'
import axios, { Axios, AxiosError } from 'axios'
import { computed, getCurrentInstance, inject, ref } from 'vue'
import { createInternalEndpointName } from './base'

import type { AxiosResponse, InternalAxiosRequestConfig } from 'axios'
import type { Ref } from 'vue'
import type { AsyncComposableOptions, ComposableOptions, Credentials, ExtendedInternalAxiosRequestConfig, InternalEnpoints, LoginComposableOptions, Methods, RefreshApiResponse, RequestStoreClass } from './types'

export type RequestStatus = 'idle' | 'pending' | 'success' | 'error'

/**
 * Adds an access token to the request on authentication
 * tokens obtained for authenticating the user
 * @param request The request configuration
 */
function requestInterceptor(request: InternalAxiosRequestConfig) {
  const { get } = useCookies()
  const access = get('access')

  if (access) {
    request.headers.Authorization = `Token ${access}`
  }

  return request
}

/**
 * Interceptor used to reject a request error
 * @param error The error generated by the request
 */
function requestErrorInterceptor(error: unknown) {
  return Promise.reject(error)
}

/**
 * Interceptor used to modify the state of a response
 * @param response The response for the request
 */
async function responseInterceptor(response: AxiosResponse) {
  return response
}

/**
 * Creates an interceptor for automatically refreshing
 * access tokens created via authentication for users
 * @param domain The url domain for the request
 */
function responseErrorInterceptor(domain: string | undefined) {
  return async (error: unknown) => {
    if (error && error instanceof AxiosError) {
      if (error.response) {
        const originalRequest = error.config as ExtendedInternalAxiosRequestConfig

        if (error.response.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true

          try {
            const { get, set } = useCookies(['access', 'refresh'])
            const refresh = get<string | undefined>('refresh')

            console.log('responseErrorInterceptor: Refresh', refresh)

            const refreshClient = axios.create({ baseURL: domain })
            const response = await refreshClient.post<RefreshApiResponse>('/auth/v1/token/refresh/', { refresh })

            set('access', response.data.access, { secure: true, sameSite: 'strict' })

            return refreshClient
          } catch (refreshError) {
            return Promise.reject(refreshError)
          }
        }
      }
    }
    return Promise.reject(error)
  }
}

/**
 * Compsable used to send a request
 * @param name The name of the client to use
 * @param path The path to get on the client's domain
 * @param params Additional options for the composable
 */
export function useRequest<T>(name: string, path: string, params?: ComposableOptions<T>) {
  const app = getCurrentInstance()
  console.log('useRequest.app', app)
  const internalName = createInternalEndpointName(name)

  let client: Axios | undefined = app?.appContext.config.globalProperties[internalName]
  let endpoint: InternalEnpoints | undefined

  console.log('useRequest: app?.appContext.config.globalProperties', app?.appContext.config.globalProperties)

  if (!app) {
    // If the composable is used store for example, the app current
    // instance is "undefined" and so as the "client". The use thus has to
    // use the fallback baseUrl in order to auto-create a usable client for
    // this specific context
    if (params?.baseUrl) {
      client = axios.create({
        baseURL: params.baseUrl,
        headers: { 'Content-Type': 'application/json' },
        withCredentials: true,
        timeout: 20000
      })

      // Create an endpoint for internal tracking
      endpoint = {
        name: `auto-created-${name}`,
        instance: client,
        endpointDomain: params.baseUrl,
        internalName: `$auto-create-${name}`
      }
    }
  } else {
    console.log('useRequest: appContext', app.appContext)
    console.log('useRequest: config', app.appContext.config)
    console.log('useRequest: provide', app.appContext.config.globalProperties)
    console.log(endpoint)
  }

  if (!client) {
    // Since we have nothing to work with, just throw an error
    throw new Error('UseRequest cannot get app current instance. You need to specify baseUrl')
  }

  try {
    client.interceptors.request.use(requestInterceptor, requestErrorInterceptor)
    client.interceptors.response.use(responseInterceptor, responseErrorInterceptor(client.defaults.baseURL))
  } catch {
    throw new Error(`Api client name "${name}" does not exist`)
  }

  let store: RequestStoreClass | undefined

  if (app) {
    // If we are in the context of a component
    // try to get the store with inject for
    // internal debug tracking
    store = inject<RequestStoreClass>('requestStore')
  }

  console.log('useRequest: RequestStore', store)

  const responseData = ref<T>()
  const status = ref<RequestStatus>('idle')

  /**
   * Function used to send a request
   * @param method Method to use for the given request
   * @param data Post data to pass to the body of the request
   * @param options Options to send with the request
   */
  async function execute() {
    if (params?.beforeStart) {
      params.beforeStart()
    }

    try {
      const method: Methods = params?.method || 'get'
      let response: AxiosResponse<T>

      status.value = 'pending'

      if (client) {
        if (method === 'get') {
          response = await client.get(path, { params: params?.query })
        } else {
          response = await client[method](path, params?.body)
        }

        status.value = 'success'

        if (params?.completed) {
          params.completed(response)
        }

        console.log('execute.response', response)
        console.log('execute.store', store)

        if (store) {
          try {
            store.registerRequest({
              name,
              method,
              statusText: response.statusText,
              data: response.data || {},
              headers: JSON.stringify(response.headers),
              path: response.config.url
            })
          } catch (e) {
            console.error(e)
          }
        }

        console.log('useRequest: status', status.value)
        console.log('useRequest: responseData.value', responseData.value)
        console.log('useRequest: response.data', response.data)

        responseData.value = response.data
      }
    } catch (e) {
      if (e && e instanceof AxiosError) {
        console.log('useRequest: Bubbled up error', e)
        status.value = 'error'
      }
    }
  }

  // TODO: Infer type
  if (params?.watch) {
    console.log('useRequest: Watch', params.watch)
    watchDebounced(params.watch, async () => {
      await execute()
    }, {
      debounce: 300,
      onTrigger() {
        console.log('useRequest: Watch', 'Executed')
      }
    })
  }

  return {
    /**
     * The status of the request
     */
    status,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * Function to execute the request
     */
    execute
  }
}

/**
 * Async composable with the option of immediately sending the request
 * or delaying the request until a certain time
 * @param name The name of the client to use
 * @param path The path to get on the client's domain
 * @param params Additional options for the composable
 */
export async function useAsyncRequest<T>(name: string, path: string, params?: AsyncComposableOptions<T>) {
  // FIXME: When trying to send a request with use async in "immediate", the
  // app in useRequest is "undefined" ->
  // 1. This might be due to the fact of using a composable within a composable ??
  // 2. This might be due to the useDebounceFn
  const { execute, responseData, status } = useRequest(name, path, params)
  const debouncedExecute = useDebounceFn(execute, params?.debounce || 0)

  if (params?.immediate) {
    await debouncedExecute()
  }

  const completed = computed(() => status.value === 'success')

  return {
    /**
     * Wrapped execute function that can be debounced
     */
    debouncedExecute,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * The status of the request
     */
    status,
    /**
     * Whether the request was completed
     */
    completed
  }
}

/**
 * Composable to log a user into the application
 * @param credentials The crendentials with which to log the user in
 * @param clientName The client name to use
 * @param path The path to log the client in
 * @param params The parameters for the request
 */
export async function useAxiosLogin<T>(credentials: Credentials, clientName: string, path: string, params: LoginComposableOptions<T>): Promise<Ref<T | unknown>> {
  const { execute, responseData } = useRequest<T>(clientName, path, { method: 'post', body: credentials, ...params })
  await execute()
  return responseData
}
