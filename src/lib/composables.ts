import { createGlobalState, isDefined, reactify, useDebouncedRefHistory, useDebounceFn, watchDebounced } from '@vueuse/core'
import { useJwt } from '@vueuse/integrations'
import type { AxiosResponse, InternalAxiosRequestConfig } from 'axios'
import axios, { AxiosError } from 'axios'
import cookie from 'universal-cookie'
import type { ComputedRef, Ref } from 'vue'
import { computed, getCurrentInstance, isRef, ref } from 'vue'
import { vueAxiosManager } from './manager'
import type { AsyncComposableOptions, ComposableOptions, Credentials, ExtendedInternalAxiosRequestConfig, ExtendedJwt, InternalEnpointOptions, LoginApiResponse, LoginComposableOptions, Methods, PluginOptions, QueryType, RefreshApiResponse, StringTypes, Undefineable } from './types'

export type RequestStatus = 'idle' | 'pending' | 'success' | 'error'

/**
 * Retrieves a value from a cookie
 * @param key The value to return from the cookie
 */
function getFromCookie<T extends Undefineable<string>>(key: string): T {
  const instance = new cookie()
  return instance.get(key) as T
}

/**
 * The value to set in a cookie
 * @param key The key to set in the cookie
 * @param value The value to set in the cookie
 */
function setInCookie(key: string, value: string) {
  const instance = new cookie()
  instance.set(key, value, { secure: true, sameSite: 'strict', path: '/' })
}

/**
 * Adds an access token to the request on authentication
 * tokens obtained for authenticating the user. The "Authorization" header
 * is added to the request only if an access token is found in the cookies
 * @param options The plugin options
 * @param endpoint The endpoint options
 */
function requestInterceptor(options: PluginOptions | undefined, endpoint: InternalEnpointOptions) {
  return (request: InternalAxiosRequestConfig) => {
    // const { get } = useCookies()

    const bearer = endpoint.bearer || options?.bearer || 'Token'
    // const access = get(endpoint.accessKey || 'access')
    const access = getFromCookie<string>(endpoint.accessKey || 'access')

    if (access && !endpoint.disableAccess) {
      request.headers.Authorization = `${bearer} ${access}`
    }

    return request
  }
}

/**
 * Interceptor used to reject a request error
 * @param error The error generated by the request
 */
function requestErrorInterceptor(error: unknown) {
  return Promise.reject(error)
}

/**
 * Interceptor used to modify the state of a response
 * @param response The response for the request
 */
async function responseInterceptor(response: AxiosResponse) {
  return response
}

/**
 * Creates an interceptor for automatically refreshing
 * access tokens created via authentication for users
 * @param domain The url domain for the request
 * @param endpoint The endpoint options
 */
function responseErrorInterceptor(domain: string | undefined, endpoint: InternalEnpointOptions) {
  return async (error: unknown) => {
    if (error && error instanceof AxiosError) {
      // console.log('responseErrorInterceptor: endpoint.disableAuth', endpoint.disableRefresh)
      if (endpoint.disableRefresh) {
        return Promise.reject(error)
      }

      if (error.response) {
        const originalRequest = error.config as ExtendedInternalAxiosRequestConfig

        if (error.response.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true

          try {
            const accessTokenKey = endpoint.accessKey || 'access'
            const refreshTokenKey = endpoint.refreshKey || 'refresh'

            // const { get, set } = useCookies([accessTokenKey, refreshTokenKey])
            // const refresh = get<string | undefined>(refreshTokenKey)
            const refresh = getFromCookie(refreshTokenKey)

            // console.log('responseErrorInterceptor: Refresh', refresh)

            const refreshClient = axios.create({ baseURL: domain })
            const refreshTokenEndpoint = endpoint.refreshEnpoint || '/v1/token/refresh/'
            const response = await refreshClient.post<RefreshApiResponse>(refreshTokenEndpoint, { refresh })

            // set(accessTokenKey, response.data.access, { secure: true, sameSite: 'strict' })
            setInCookie(accessTokenKey, response.data.access)

            return refreshClient
          } catch (refreshError) {
            return Promise.reject(refreshError)
          }
        }
      }
    }
    return Promise.reject(error)
  }
}

/**
 * Composable used to send a request
 * @param name The name of the endpoint to use
 * @param path The path to get on the endpoint's domain
 * @param params Additional options for the composable
 */
export function useRequest<T>(name: string, path: string, params?: ComposableOptions<T>) {
  const app = getCurrentInstance()
  const isAppContext = computed(() => isDefined(app))

  const endpoint = vueAxiosManager.provideAttr[name]
  // console.log('vueAxiosManager.endpoints', vueAxiosManager.endpoints)
  // console.log('vueAxiosManager', vueAxiosManager.provideAttr[name]?.internalName)

  if (typeof endpoint === 'undefined') {
    throw new Error(`Endpoint with with name ${name} does not exist`)
  }

  // Initial client from the endpoint
  let client = endpoint.instance

  // console.log('useRequest: client', typeof client)
  // console.log('vueAxiosManager', vueAxiosManager)

  // baseUrl allows the user to override
  // the initial endpoint url entirely for this
  // request -; this creates a new client
  if (params?.baseUrl) {
    client = axios.create({
      baseURL: params.baseUrl, // We allow http or https protocoles here
      ...endpoint.axios
    })
  }

  try {
    const activeEndpoint = vueAxiosManager.provideAttr[name]
    client.interceptors.request.use(requestInterceptor(vueAxiosManager.pluginOptions, activeEndpoint), requestErrorInterceptor)
    client.interceptors.response.use(responseInterceptor, responseErrorInterceptor(client.defaults.baseURL, activeEndpoint))
  } catch (e) {
    // @ts-expect-error Error could be anything so skip
    throw new Error(e)
  }

  if (isAppContext.value) {
    // If we are in the context of a component
    // try to get the store with inject for
    // internal debug tracking
  }

  // console.log('useRequest: RequestStore', store)

  const responseData = ref<T>()
  const status = ref<RequestStatus>('idle')

  /**
   * Function used to send a request
   * @param method Method to use for the given request
   * @param data Post data to pass to the body of the request
   * @param options Options to send with the request
   */
  async function execute() {
    if (params?.beforeStart) {
      params.beforeStart()
    }

    try {
      const method: Methods = params?.method || 'get'
      let response: AxiosResponse<T>

      status.value = 'pending'

      // TODO: Implement memoize for caching
      // const { load } = useMemoize(async (routePath: string) => {
      //   if (method == 'get') {
      //     return await client.get<T>(routePath, { params: params?.query })
      //   } else {
      //     return await client[method]<T>(routePath, params?.body)
      //   }
      // })

      // If the user passes refs in the query params,
      // we need to unwrap them before sending the request.
      // The tracking of the ref is still maintained via
      // and updated in the request's query
      const cleanSearchParams = (value: Undefineable<QueryType>) => {
        const cleanedParams: Record<string, StringTypes> = {}

        if (isDefined(value)) {
          Object.entries(value).forEach(([key, val]) => {
            if (isRef(val)) {
              cleanedParams[key] = val.value
            } else {
              cleanedParams[key] = val
            }
          })
          return cleanedParams
        }
      }

      if (method === 'get') {
        response = await client.get<T>(path, { params: cleanSearchParams(params?.query) })
      } else {
        response = await client[method]<T>(path, params?.body)
      }

      status.value = 'success'

      if (params?.completed) {
        params.completed(response)
      }

      try {
        vueAxiosManager._registerRequest(method, endpoint, {
          name,
          method,
          statusText: 'OK',
          data: (response.data ?? response.data) || {},
          headers: JSON.stringify(response.headers),
          path: response.config?.url
        })
      } catch (e) {
        console.error(e)
      }

      // console.log('execute.response', response)
      // console.log('execute.store', store)

      // console.log('useRequest: status', status.value)
      // console.log('useRequest: responseData.value', responseData.value)
      // console.log('useRequest: response.data', response.data)

      responseData.value = response.data
    } catch (e) {
      status.value = 'error'

      if (e && e instanceof AxiosError) {
        console.log('useRequest: Bubbled up error', e.response)

        // try {
        //   vueAxiosManager._registerRequest(e.config?.method, endpoint, {
        //     name,
        //     method: e.config?.method,
        //     statusText: e.response?.statusText,
        //     data: e.response?.data || {},
        //     headers: JSON.stringify(e.response?.headers),
        //     path: e.response?.config?.url
        //   }, null, true)
        // } catch (e) {
        //   console.log(e)
        // }
      }
    }
  }

  if (params?.watch) {
    // console.log('useRequest: Watch', params.watch)

    watchDebounced(params.watch, async () => {
      await execute()
    }, {
      debounce: 300,
      onTrigger() {
        // console.log('useRequest: Watch', 'Executed')
      }
    })

    // const { trigger } = watchTriggerable(params.watch, async () => {
    //   const debouncedExecute = useDebounceFn(async () => await execute(), 3000)
    //   await debouncedExecute()
    //   await execute()
    // })
  }

  return {
    /**
     * The status of the request
     */
    status,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * Function to execute the request
     */
    execute
  }
}

/**
 * Async composable with the option of immediately sending the request
 * or delaying it until a certain time
 * @param name The name of the endpoint to use
 * @param path The path to get on the endpoint's domain
 * @param params Additional options for the composable
 */
export async function useAsyncRequest<T>(name: string, path: string, params?: AsyncComposableOptions<T>) {
  // FIXME: When trying to send a request with use async in "immediate", the
  // app in useRequest is "undefined" ->
  // 1. This might be due to the fact of using a composable within a composable ??
  // 2. This might be due to the useDebounceFn
  const { execute: syncExecute, responseData, status } = useRequest(name, path, params)
  const execute = useDebounceFn(syncExecute, params?.debounce || 0)

  if (params?.immediate) {
    await execute()
  }

  const completed = computed(() => status.value === 'success')

  return {
    /**
     * Wrapped execute function that can be debounced
     */
    execute,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * The status of the request
     */
    status,
    /**
     * Whether the request was completed
     */
    completed
  }
}

/**
 * Composable to log a user into the application
 * @param credentials The crendentials with which to log the user in
 * @param clientName The client name to use
 * @param path The path to log the client in
 * @param params The parameters for the request
 */
export async function useAxiosLogin<T = LoginApiResponse>(credentials: Credentials, clientName: string, path: string, params?: LoginComposableOptions<T>): Promise<Ref<T | undefined>> {
  const { execute, responseData } = useRequest<T>(clientName, path, { method: 'post', body: credentials, ...params })
  await execute()
  return responseData
}

/**
 * Composable to retrieve the access token from the cookies
 * and maintain a history of the last three access tokens
 * @private v2.1.0
 */
export const useAccessToken = createGlobalState(() => {
  const getAccessToken = reactify(getFromCookie)
  const access = getAccessToken('access') as ComputedRef<Undefineable<string>>
  const { history } = useDebouncedRefHistory(access, { capacity: 3, deep: false })

  return {
    /**
     * The current access token
     * @default undefined
     */
    access,
    /**
     * History of the last three access tokens
     * @default []
     */
    history
  }
})

/**
 * Composable to retrieve the user id from the JWT access token
 * and makes it available globally
 * @private v2.1.0
 */
export const useUser = createGlobalState(<T>(column?: keyof T) => {
  const { access } = useAccessToken()
  const { payload } = useJwt<ExtendedJwt<T>>(access.value as string)

  const id = computed(() => {
    if (isDefined(payload)) {
      const columnName = column || 'id'
      // @ts-expect-error Dynamic key access
      return payload.value[columnName]
    } else {
      return undefined
    }
  })

  // console.log('useUser: jwtPayload', payload.value)

  return {
    /**
     * The user id from the JWT access token
     * @default undefined
     */
    id
  }
})
