import { useDebounceFn, watchDebounced } from '@vueuse/core'
import { useCookies } from '@vueuse/integrations/useCookies.mjs'
import axios, { AxiosError } from 'axios'
import { computed, getCurrentInstance, ref } from 'vue'
import { vueAxiosManager } from './base'

import type { AxiosResponse, InternalAxiosRequestConfig } from 'axios'
import type { Ref } from 'vue'
import type { AsyncComposableOptions, ComposableOptions, Credentials, ExtendedInternalAxiosRequestConfig, InternalEnpointOptions, LoginComposableOptions, Methods, PluginOptions, RefreshApiResponse } from './types'

export type RequestStatus = 'idle' | 'pending' | 'success' | 'error'

/**
 * Adds an access token to the request on authentication
 * tokens obtained for authenticating the user
 * @param request The request configuration
 */
function requestInterceptor(options: PluginOptions | undefined, endpoint: InternalEnpointOptions) {
  return (request: InternalAxiosRequestConfig) => {
    const { get } = useCookies()

    const bearer = endpoint.bearer || options?.bearer || 'Token'
    const access = get(endpoint.accessKey || 'access')

    if (access && !endpoint.disableAccess) {
      request.headers.Authorization = `${bearer} ${access}`
    }

    return request
  }
}

/**
 * Interceptor used to reject a request error
 * @param error The error generated by the request
 */
function requestErrorInterceptor(error: unknown) {
  return Promise.reject(error)
}

/**
 * Interceptor used to modify the state of a response
 * @param response The response for the request
 */
async function responseInterceptor(response: AxiosResponse) {
  return response
}

/**
 * Creates an interceptor for automatically refreshing
 * access tokens created via authentication for users
 * @param domain The url domain for the request
 */
function responseErrorInterceptor(domain: string | undefined, endpoint: InternalEnpointOptions) {
  return async (error: unknown) => {
    if (error && error instanceof AxiosError) {
      // console.log('responseErrorInterceptor: endpoint.disableAuth', endpoint.disableRefresh)
      if (endpoint.disableRefresh) {
        return Promise.reject(error)
      }

      if (error.response) {
        const originalRequest = error.config as ExtendedInternalAxiosRequestConfig

        if (error.response.status === 401 && !originalRequest._retry) {
          originalRequest._retry = true

          try {
            const accessTokenKey = endpoint.accessKey || 'access'
            const refreshTokenKey = endpoint.refreshKey || 'refresh'

            const { get, set } = useCookies([accessTokenKey, refreshTokenKey])
            const refresh = get<string | undefined>(refreshTokenKey)

            // console.log('responseErrorInterceptor: Refresh', refresh)

            const refreshClient = axios.create({ baseURL: domain })
            const refreshTokenEndpoint = endpoint.refreshEnpoint || '/auth/v1/token/refresh/'
            const response = await refreshClient.post<RefreshApiResponse>(refreshTokenEndpoint, { refresh })

            set(accessTokenKey, response.data.access, { secure: true, sameSite: 'strict' })

            return refreshClient
          } catch (refreshError) {
            return Promise.reject(refreshError)
          }
        }
      }
    }
    return Promise.reject(error)
  }
}

/**
 * Compsable used to send a request
 * @param name The name of the client to use
 * @param path The path to get on the client's domain
 * @param params Additional options for the composable
 */
export function useRequest<T>(name: string, path: string, params?: ComposableOptions<T>) {
  const app = getCurrentInstance()
  const isAppContext = computed(() => app !== null)

  const endpoint = vueAxiosManager.provideAttr[name]
  // console.log('vueAxiosManager', vueAxiosManager.provideAttr[name]?.internalName)

  if (typeof endpoint === 'undefined') {
    throw new Error(`Endpoint with with name ${name} does not exist`)
  }

  let client = endpoint.instance

  // console.log('vueAxiosManager', vueAxiosManager)

  // baseUrl allows the user to override
  // the initial client entirely for this
  // request -; this creates a new client
  if (params?.baseUrl) {
    client = axios.create({
      baseURL: params.baseUrl, // We allow http or https protocoles here
      ...endpoint.axios
    })
  }

  try {
    const activeEndpoint = vueAxiosManager.provideAttr[name]
    client.interceptors.request.use(requestInterceptor(vueAxiosManager.pluginOptions, activeEndpoint), requestErrorInterceptor)
    client.interceptors.response.use(responseInterceptor, responseErrorInterceptor(client.defaults.baseURL, activeEndpoint))
  } catch (e) {
    // @ts-expect-error Error could be anything so skip
    throw new Error(e)
  }

  if (isAppContext.value) {
    // If we are in the context of a component
    // try to get the store with inject for
    // internal debug tracking
  }

  // console.log('useRequest: RequestStore', store)

  const responseData = ref<T>()
  const status = ref<RequestStatus>('idle')

  /**
   * Function used to send a request
   * @param method Method to use for the given request
   * @param data Post data to pass to the body of the request
   * @param options Options to send with the request
   */
  async function execute() {
    if (params?.beforeStart) {
      params.beforeStart()
    }

    try {
      const method: Methods = params?.method || 'get'
      let response: AxiosResponse<T>

      status.value = 'pending'

      if (method === 'get') {
        response = await client.get<T>(path, { params: params?.query })
      } else {
        response = await client[method]<T>(path, params?.body)
      }

      status.value = 'success'

      if (params?.completed) {
        params.completed(response)
      }

      try {
        vueAxiosManager._registerRequest(method, endpoint, {
          name,
          method,
          statusText: 'OK',
          data: (response.data ?? response.data) || {},
          headers: JSON.stringify(response.headers),
          path: response.config?.url
        })
      } catch (e) {
        console.error(e)
      }

      // console.log('execute.response', response)
      // console.log('execute.store', store)

      // console.log('useRequest: status', status.value)
      // console.log('useRequest: responseData.value', responseData.value)
      // console.log('useRequest: response.data', response.data)

      responseData.value = response.data
    } catch (e) {
      status.value = 'error'

      if (e && e instanceof AxiosError) {
        console.log('useRequest: Bubbled up error', e)

        // try {
        //   vueAxiosManager._registerRequest(e.config?.method, endpoint, {
        //     name,
        //     method: e.config?.method,
        //     statusText: e.response?.statusText,
        //     data: e.response?.data || {},
        //     headers: JSON.stringify(e.response?.headers),
        //     path: e.response?.config?.url
        //   }, null, true)
        // } catch (e) {
        //   console.log(e)
        // }
      }
    }
  }

  // TODO: Infer type
  if (params?.watch) {
    // console.log('useRequest: Watch', params.watch)
    watchDebounced(params.watch, async () => {
      await execute()
    }, {
      debounce: 300,
      onTrigger() {
        // console.log('useRequest: Watch', 'Executed')
      }
    })
  }

  return {
    /**
     * The status of the request
     */
    status,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * Function to execute the request
     */
    execute
  }
}

/**
 * Async composable with the option of immediately sending the request
 * or delaying the request until a certain time
 * @param name The name of the client to use
 * @param path The path to get on the client's domain
 * @param params Additional options for the composable
 */
export async function useAsyncRequest<T>(name: string, path: string, params?: AsyncComposableOptions<T>) {
  // FIXME: When trying to send a request with use async in "immediate", the
  // app in useRequest is "undefined" ->
  // 1. This might be due to the fact of using a composable within a composable ??
  // 2. This might be due to the useDebounceFn
  const { execute: syncExecute, responseData, status } = useRequest(name, path, params)
  const execute = useDebounceFn(syncExecute, params?.debounce || 0)

  if (params?.immediate) {
    await execute()
  }

  const completed = computed(() => status.value === 'success')

  return {
    /**
     * Wrapped execute function that can be debounced
     */
    execute,
    /**
     * Data received from the request
     */
    responseData,
    /**
     * The status of the request
     */
    status,
    /**
     * Whether the request was completed
     */
    completed
  }
}

/**
 * Composable to log a user into the application
 * @param credentials The crendentials with which to log the user in
 * @param clientName The client name to use
 * @param path The path to log the client in
 * @param params The parameters for the request
 */
export async function useAxiosLogin<T>(credentials: Credentials, clientName: string, path: string, params?: LoginComposableOptions<T>): Promise<Ref<T | unknown>> {
  const { execute, responseData } = useRequest<T>(clientName, path, { method: 'post', body: credentials, ...params })
  await execute()
  return responseData
}
